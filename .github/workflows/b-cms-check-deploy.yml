name: PayloadCMS Check. If changes detected, Deploy new image

on:
  workflow_call:
    inputs:
      environment:
        required: true
        type: string
        description: "The deployment environment to use"
      github_username:
        required: true
        type: string
        description: "GitHub username for Docker image naming"
      repo_name:
        required: true
        type: string
        description: "Repository name for Docker image naming"
      project_year:
        required: true
        type: string
        description: "Project year identifier"
      project_prefix:
        required: true
        type: string
        description: "Project prefix for container naming"
      cms_dir:
        required: true
        type: string
        description: "Directory name for CMS files"
      image_name:
        required: true
        type: string
        description: "Name of the Docker image (without registry prefix)"
      cms_container_name:
        required: true
        type: string
        description: "Name of the CMS container"
      db_container_name:
        required: true
        type: string
        description: "Name of the database container"
      network_name:
        required: true
        type: string
        description: "Docker network name"
    secrets:
      LINUX_SSH_PRIVATE_KEY:
        required: true
      LINUX_CICDGHA_USERNAME:
        required: true
      LINUX_SERVER_IP:
        required: true
      GHPAT__CICDUSER__REPO_WORKFLOW_WRDPACKAGES:
        required: true
      PAYLOAD__SECRET_ENV_FILE:
        required: true
    outputs:
      had_changes:
        description: "Whether changes were detected"
        value: ${{ jobs.job-deploy--cms.outputs.changes_detected }}
      action:
        description: "Action taken during deployment"
        value: ${{ jobs.job-deploy--cms.outputs.action }}
      changed_files:
        description: "List of files that were changed"
        value: ${{ jobs.job-deploy--cms.outputs.changed_files }}
      changed_files_count:
        description: "Number of files that were changed"
        value: ${{ jobs.job-deploy--cms.outputs.changed_files_count }}
jobs:
  job-deploy--cms:
    environment: production
    runs-on: ubuntu-latest
    permissions:
      contents: read
      actions: write # Needed for artifact operations
    outputs:
      changes_detected: ${{ steps.check-changes.outputs.changes }}
      action: ${{ steps.step-deploy--cms.outputs.action_taken }}
      changed_files: ${{ steps.changed-files.outputs.files }}
      changed_files_count: ${{ steps.changed-files.outputs.count }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Full history needed for better change detection

      # Setup GitHub CLI for artifact operations
      - name: Setup GitHub CLI
        run: |
          echo "Setting up GitHub CLI authentication..."
          echo ${{ github.token }} | gh auth login --with-token

      # Download last successful deployment marker if it exists
      - name: Download last successful deployment marker
        id: download-marker
        continue-on-error: true # Continue if no marker exists yet
        run: |
          mkdir -p ./deployment-markers

          # Try to download the artifact using the GitHub CLI
          echo "Attempting to download latest cms-last-deployed-commit artifact..."
          gh run download --name cms-last-deployed-commit --dir ./deployment-markers --repo ${{ github.repository }} || echo "⚠️ No previous deployment marker found or download failed"

          # Check if the download was successful
          if [ -f "./deployment-markers/last-cms-commit.txt" ]; then
            echo "✅ Successfully downloaded previous deployment marker"
          else
            # List available artifacts for debugging
            echo "Available artifacts:"
            gh artifact list --repo ${{ github.repository }} | grep -i cms || echo "No matching artifacts found"
          fi

      # Determine last deployed commit hash
      - name: Get last deployed commit hash
        id: get-last-commit
        run: |
          if [ -f "./deployment-markers/last-cms-commit.txt" ]; then
            LAST_COMMIT=$(cat ./deployment-markers/last-cms-commit.txt)
            echo "Last successfully deployed CMS commit: $LAST_COMMIT"
            echo "last_commit=$LAST_COMMIT" >> $GITHUB_OUTPUT
          else
            # If no marker exists, get a commit far back enough to capture all changes
            # This will trigger a build on first run
            LAST_COMMIT=$(git rev-list --max-parents=0 HEAD)
            echo "No previous deployment marker found. Using initial commit: $LAST_COMMIT"
            echo "last_commit=$LAST_COMMIT" >> $GITHUB_OUTPUT
          fi

      - name: Check CMS Directory Changes
        id: check-changes
        env:
          CMS_DIR: ${{ inputs.cms_dir }}
        run: |
          echo "Checking for code changes in CMS directory since last deployment..."

          # Debug: Show the commit we're comparing against
          echo "Comparing current commit with: ${{ steps.get-last-commit.outputs.last_commit }}"

          # List files in PayloadCMS directory without showing content
          echo "Files in PayloadCMS directory (names only):"
          ls -la ./$CMS_DIR | grep -v "^total"
            
          # Check for changes between last deployed commit and current HEAD
          # Only show file names, not content
          CHANGES=$(git diff --name-only ${{ steps.get-last-commit.outputs.last_commit }} HEAD -- ./$CMS_DIR)

          if [ -z "$CHANGES" ]; then
            echo "No changes detected in $CMS_DIR directory since last deployment"
            echo "changes=false" >> $GITHUB_OUTPUT
          else
            echo "Changes detected in $CMS_DIR directory since last deployment:"
            # Only show file names that changed, not their content
            echo "$CHANGES"
            echo "changes=true" >> $GITHUB_OUTPUT
            
            # Save changed files list to be accessed by the deployment summary
            echo "$CHANGES" > ./cms-changed-files.txt
          fi

      # Save changed files to an output instead of using artifacts
      - name: Set changed files as output
        if: steps.check-changes.outputs.changes == 'true'
        id: changed-files
        run: |
          # Use GitHub's multiline output syntax
          echo "files<<EOF" >> $GITHUB_OUTPUT
          cat ./cms-changed-files.txt >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          # Count the number of changed files correctly
          CHANGE_COUNT=$(cat ./cms-changed-files.txt | wc -l | xargs)
          echo "count=$CHANGE_COUNT" >> $GITHUB_OUTPUT

      - name: Install YQ
        run: |
          wget https://github.com/mikefarah/yq/releases/download/v4.34.1/yq_linux_amd64 -O /usr/local/bin/yq
          chmod +x /usr/local/bin/yq

      - name: Load Environment Defaults
        id: env-defaults
        env:
          CMS_DIR: ${{ inputs.cms_dir }}
        run: |
          # Extract PayloadCMS environment variables from defaults file
          PAYLOAD_DEFAULTS=$(yq e '.payloadcms_defaults' .github/defaults/env-defaults.yml)

          # Create .env file in the project directory
          echo "$PAYLOAD_DEFAULTS" > ./$CMS_DIR/.env

          # Also save as a project-specific name for reference
          echo "$PAYLOAD_DEFAULTS" > ./$CMS_DIR/${{ inputs.project_prefix }}-cms-env-prod.env

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ inputs.github_username }}
          password: ${{ secrets.GHPAT__CICDUSER__REPO_WORKFLOW_WRDPACKAGES }}

      - name: Build & Publish image
        id: build-publish
        if: steps.check-changes.outputs.changes == 'true'
        env:
          GITHUB_USERNAME: ${{ inputs.github_username }}
          IMAGE_NAME: ${{ inputs.image_name }}
          CMS_DIR: ${{ inputs.cms_dir }}
        run: |
          echo "Building updated PayloadCMS Docker image..."

          # Build the PayloadCMS Docker image with env file
          # Note: We're not passing ENV_FILE as build arg since we created .env directly in the project dir
          docker build \
            --build-arg NODE_ENV=production \
            -t ghcr.io/$GITHUB_USERNAME/$IMAGE_NAME:latest \
            ./$CMS_DIR

          # Push the Docker image to GitHub Container Registry
          docker push ghcr.io/$GITHUB_USERNAME/$IMAGE_NAME:latest

          # Clean up
          rm ./$CMS_DIR/.env
          rm ./$CMS_DIR/${{ inputs.project_prefix }}-cms-env-prod.env

          echo "BUILT=true" >> $GITHUB_ENV
          echo "PUSHED=true" >> $GITHUB_ENV
          echo "build_status=success" >> $GITHUB_OUTPUT

      - name: SSH in and Deploy Updated CMS image
        id: step-deploy--cms
        env:
          SSH_KEY: ${{ secrets.LINUX_SSH_PRIVATE_KEY }}
          SSH_USER: ${{ secrets.LINUX_CICDGHA_USERNAME }}
          SERVER_IP: ${{ secrets.LINUX_SERVER_IP }}
          GHPAT__CICDUSER__REPO_WORKFLOW_WRDPACKAGES: ${{ secrets.GHPAT__032725_REPO_WORKFLOW_WRDPACKAGES }}
          PAYLOAD_ENV: ${{ secrets.PAYLOAD__SECRET_ENV_FILE }}
          GITHUB_USERNAME: ${{ inputs.github_username }}
          IMAGE_NAME: ${{ inputs.image_name }}
          CMS_CONTAINER_NAME: ${{ inputs.cms_container_name }}
          DB_CONTAINER_NAME: ${{ inputs.db_container_name }}
          NETWORK_NAME: ${{ inputs.network_name }}
        run: |
          # Debug environment variables
          echo "Debug - Checking if variables are set:"
          echo "SSH_USER is set: $(if [ -n "$SSH_USER" ]; then echo "YES"; else echo "NO"; fi)"
          echo "SERVER_IP is set: $(if [ -n "$SERVER_IP" ]; then echo "YES"; else echo "NO"; fi)"
          echo "GHPAT__CICDUSER__REPO_WORKFLOW_WRDPACKAGES is set: $(if [ -n "$GHPAT__CICDUSER__REPO_WORKFLOW_WRDPACKAGES" ]; then echo "YES"; else echo "NO"; fi)"
          echo "PAYLOAD_ENV is set: $(if [ -n "$PAYLOAD_ENV" ]; then echo "YES"; else echo "NO"; fi)"
          echo "CMS_CONTAINER_NAME is: $CMS_CONTAINER_NAME"
          echo "DB_CONTAINER_NAME is: $DB_CONTAINER_NAME"
          echo "NETWORK_NAME is: $NETWORK_NAME"

          # Setup SSH
          mkdir -p ~/.ssh/
          echo "$SSH_KEY" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519

          # Create SSH config with direct variable expansion
          cat > ~/.ssh/config << EOF
          Host prod
            HostName $SERVER_IP
            User $SSH_USER
            IdentityFile ~/.ssh/id_ed25519
            StrictHostKeyChecking no
          EOF

          # Verify connection to server with simple commands
          echo "Verifying server connection..."
          ssh prod "hostname && which docker && /usr/bin/docker ps -a && uptime"

          if [[ "${{ steps.check-changes.outputs.changes }}" == "true" ]]; then
            # First authenticate with GHCR on the remote server
            echo "Authenticating with GitHub Container Registry on remote server..."
            ssh prod "echo '$GHPAT__CICDUSER__REPO_WORKFLOW_WRDPACKAGES' | docker login ghcr.io -u $GITHUB_USERNAME --password-stdin"
            
            # Create a temporary env file on the remote server
            echo "Creating temporary environment file..."
            ssh prod "echo '$PAYLOAD_ENV' > ~/${{ inputs.project_prefix }}-cms-env-prod.env"
            ssh prod "ls -la ~/${{ inputs.project_prefix }}-cms-env-prod.env" # Check if file exists and permissions
            ssh prod "wc -l ~/${{ inputs.project_prefix }}-cms-env-prod.env" # Count number of lines

            # Ensure network exists
            ssh prod "docker network create $NETWORK_NAME || true"

            # Deploy using docker run with environment file and update DB URI to use correct container name
            ssh prod "docker pull ghcr.io/$GITHUB_USERNAME/$IMAGE_NAME:latest && \
              docker rm -f $CMS_CONTAINER_NAME || true && \
              docker run -d \
                --name $CMS_CONTAINER_NAME \
                --network $NETWORK_NAME \
                -p 3000:3000 \
                --env-file ~/${{ inputs.project_prefix }}-cms-env-prod.env \
                ghcr.io/$GITHUB_USERNAME/$IMAGE_NAME:latest"
            
            # Remove the temporary env file for security
            echo "Removing temporary environment file..."
            ssh prod "rm ~/${{ inputs.project_prefix }}-cms-env-prod.env"
            
            echo "Deploying new CMS version..."
            echo "action_taken=New version deployed" >> $GITHUB_OUTPUT
            echo "deploy_status=success" >> $GITHUB_ENV
          else
            echo "No changes detected, skipping deployment"
            echo "action_taken=No deployment needed" >> $GITHUB_OUTPUT
          fi

      # Save deployment marker if deploy was successful
      - name: Save deployment marker
        if: steps.check-changes.outputs.changes == 'true' && env.deploy_status == 'success'
        run: |
          mkdir -p ./deployment-markers
          git rev-parse HEAD > ./deployment-markers/last-cms-commit.txt
          echo "Saved current commit as last deployed commit marker"

      # Upload the marker as an artifact
      - name: Upload deployment marker
        if: steps.check-changes.outputs.changes == 'true' && env.deploy_status == 'success'
        uses: actions/upload-artifact@v4
        with:
          name: cms-last-deployed-commit
          path: ./deployment-markers/last-cms-commit.txt
          retention-days: 90

      - name: Status Report
        run: |
          echo "CMS Deployment Status:"
          echo "Changes Detected: ${{ steps.check-changes.outputs.changes }}"
          echo "Action Taken: ${{ steps.step-deploy--cms.outputs.action_taken }}"
